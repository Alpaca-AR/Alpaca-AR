<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
:root {
	--toolbar-height: 40px;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

canvas {
	display: block;
}

.toolbar {
	position: fixed;
	bottom: 0;
	left: 0;
	width: 100vw;
	height: var(--toolbar-height);
	display: flex;
	flex-direction: row;
	align-item: stretch;
	justify-content: stretch;
}

.toolbar--button {
	width: auto;
	flex: 1;
}

#theLogger {
	position: fixed;
	top: 0;
	left: 0;
	pointer-events: none;
	display: none;
}

.hide-ui .toolbar,
.hide-ui #theLogger,
.hide-ui canvas[width="80"] {
	display: none !important;
}
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css"
			integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ=="
			crossorigin=""/>
<script type="application/x-template">

</script>
<script type="x-shader/x-vertex" id="dynamicVertexShader">
precision mediump float;
precision mediump int;

varying vec2 vUv;

void main() {
	vUv = uv;
	gl_Position = vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="dynamicFragmentShader">
precision mediump float;
precision mediump int;

uniform sampler2D uTextureMap;

varying vec2 vUv;

void main() {
	vec4 color = texture2D(uTextureMap, vUv);
	if (all(lessThan(color.rgb, vec3(0.1)))) {
		discard;
	}
	gl_FragColor = vec4(color.rgb, 1.0);
}
</script>
<script type="application/x-vertex" id="projectionVertexShader" >
varying vec2 vUv;
varying float vValue;
uniform sampler2D uTextureMap;

const float cLevel0 = 50./255.;
const float cValue0 = 0.;

const float cLevel1 = 150./255.;
const float cValue1 = .75;

const float cLevel2 = 230./255.;
const float cValue2 = .5;

const float cValue3 = .25;

float lookup(vec2 uv) {
	vec4 tex = texture2D(uTextureMap, uv);
	float val = tex.r < cLevel0 ? cValue0 :
	            tex.r < cLevel1 ? cValue1 :
	            tex.r < cLevel2 ? cValue2 :
	                              cValue3;
	return val;
}

void main() {
	vUv = uv;
	float away = 2.;
	float val =
		lookup(vec2(uv.s, uv.t)) +
		lookup(vec2(uv.s - away/256., uv.t - away/256.)) +
		lookup(vec2(uv.s - 0./256., uv.t - away/256.)) +
		lookup(vec2(uv.s + away/256., uv.t - away/256.)) +
		lookup(vec2(uv.s + away/256., uv.t - 0./256.)) +
		lookup(vec2(uv.s + away/256., uv.t + away/256.)) +
		lookup(vec2(uv.s - 0./256., uv.t + away/256.)) +
		lookup(vec2(uv.s - away/256., uv.t + away/256.)) +
		lookup(vec2(uv.s - away/256., uv.t + 0./256.));
	val /= 9.;

	// = tex.a;
	vValue = val;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position + 0.2 * val * normal, 1.0);
}
</script>
<script type="application/x-fragment" id="projectionFragmentShader" >
uniform sampler2D uTextureMap;
varying vec2 vUv;
varying float vValue;

void main() {
	//if (vValue < 0.1) discard;
	float away = 2.;
	vec4 color =
		texture2D(uTextureMap, vec2(vUv.s, vUv.t)) +
		texture2D(uTextureMap, vec2(vUv.s - away/256., vUv.t - away/256.)) +
		texture2D(uTextureMap, vec2(vUv.s - 0./256., vUv.t - away/256.)) +
		texture2D(uTextureMap, vec2(vUv.s + away/256., vUv.t - away/256.)) +
		texture2D(uTextureMap, vec2(vUv.s + away/256., vUv.t - 0./256.)) +
		texture2D(uTextureMap, vec2(vUv.s + away/256., vUv.t + away/256.)) +
		texture2D(uTextureMap, vec2(vUv.s - 0./256., vUv.t + away/256.)) +
		texture2D(uTextureMap, vec2(vUv.s - away/256., vUv.t + away/256.)) +
		texture2D(uTextureMap, vec2(vUv.s - away/256., vUv.t + 0./256.));
		
	gl_FragColor = color / vec4(9.);
}
</script>
<body>
<div id="app">
	<div id="canvas"></div>
	<div class=toolbar>
		<button class="toolbar--button js-toolbar-scale">Scale</button>
		<button class="toolbar--button js-toolbar-select">Select</button>
		<button class="toolbar--button js-toolbar-recenter">Recenter</button>
	</div>
</div>
<div id="theLogger"></div>
<script>
(function() {
	console.log = makeLogger(console.log, 'log');
	console.warn = makeLogger(console.warn, 'warn');
	console.error = makeLogger(console.error, 'error');
	
	function makeLogger(old, type) {
		const logger = document.getElementById('theLogger');
		
		return function() {
			const pre = document.createElement('pre');
			const text = document.createTextNode(type + ':' + Array.from(arguments).join(''));
			pre.appendChild(text);
			logger.appendChild(pre);
			old.apply(console, arguments);
		};
		
	}
})();
</script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/c67fbdcc64ffc970d732d9d3ce77a930761f7f31/build/three.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/c67fbdcc64ffc970d732d9d3ce77a930761f7f31/examples/js/QuickHull.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/c67fbdcc64ffc970d732d9d3ce77a930761f7f31/examples/js/geometries/ConvexGeometry.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/c1afee8fea2157a3846b7b9bdf00d4f69d7076eb/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.rawgit.com/google-ar/three.ar.js/83d4f1b2626081d44a3d49a7f16846ddeb144beb/third_party/three.js/VRControls.js"></script>
<script src="https://cdn.rawgit.com/google-ar/three.ar.js/83d4f1b2626081d44a3d49a7f16846ddeb144beb/dist/three.ar.min.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/stats.js/28632bd87e0ea56acafc9b8779d813eb95e62c08/build/stats.min.js"></script>
<script src="https://unpkg.com/mathjs@4.0.0/dist/math.min.js"></script>
<script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
<script type="text/babel" data-presets="stage-0">
(async () => {

const display = do {
	await THREE.ARUtils.getARDisplay();
};

const loader = do {
	new THREE.TextureLoader();
};

const renderer = do {
	const renderer = new THREE.WebGLRenderer({ alpha: true });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.autoClear = false;
	renderer;
}

const canvas = do {
	const canvas = renderer.domElement;
	document.getElementById('canvas').appendChild(canvas);
	canvas;
}

const scenes = do {
	const main = new THREE.Scene(),
	      reticle = new THREE.Scene(),
	      scenes = { main, reticle };
	scenes;
};

const center = do {
	const geometry = do {
		const size = 0.1;
		new THREE.BoxBufferGeometry(size, size, size);
	};
	
	const material = do {
		const color = 0xff00ff;
		new THREE.MeshBasicMaterial({ color })
	};
	
	const mesh = new THREE.Mesh(geometry, material);
	//scenes.reticle.add(mesh);
	mesh;
};

const view = do {
	if (display) {
		new THREE.ARView(display, renderer);
	} else {
		null;
	}
};

const camera = do {
	const fov = 60,
	      aspect = window.innerWidth / window.innerHeight;
	if (display) {
		const zNear = display.depthNear,
		      zFar = display.depthFar;
		new THREE.ARPerspectiveCamera(display, fov, aspect, zNear, zFar);
	} else {
		const zNear = 0.1,
		      zFar = 1000,
		      c = new THREE.PerspectiveCamera(fov, aspect, zNear, zFar);
		c.position.set(0, 0.1, 0.1);
		c;
	}
};

const reticle = do {
	if (display) {
		const inRadius = 0.03,
		      outRadius = 0.04,
		      color = 0xff0077,
		      easing = 0.25,
		      r = new THREE.ARReticle(display, inRadius, outRadius, color, easing);
		scenes.reticle.add(r);
		r;
	} else {
		null;
	}
};

const controls = do {
	if (display) {
		new THREE.VRControls(camera);
	} else {
		const c = new THREE.OrbitControls(camera);
		patchControls(c);
		c;
	}
};

const p1 = do {
	const panel = do {
		const label = 'p1',
		      fg = '#ccc',
		      bg = '#222';
		new Stats.Panel(label, fg, bg);
	};
	
	const stats = do {
		const stats = new Stats();
		stats.addPanel(panel);
		stats.showPanel(3);
		stats.dom.style.top = `${0 * 48}px`;
		document.body.appendChild(stats.dom);
		stats;
	};
	
	panel;
};

const p3 = do {
	const panel = do {
		const label = 'p2',
		      fg = '#ccc',
		      bg = '#222';
		new Stats.Panel(label, fg, bg);
	};
	
	const stats = do {
		const stats = new Stats();
		stats.addPanel(panel);
		stats.showPanel(3);
		stats.dom.style.top = `${1 * 48}px`;
		document.body.appendChild(stats.dom);
		stats;
	};
	
	panel;
};

const p2 = do {
	const panel = do {
		const label = 'p3',
		      fg = '#ccc',
		      bg = '#222';
		new Stats.Panel(label, fg, bg);
	};
	
	const stats = do {
		const stats = new Stats();
		stats.addPanel(panel);
		stats.showPanel(3);
		stats.dom.style.top = `${2 * 48}px`;
		document.body.appendChild(stats.dom);
		stats;
	};
	
	panel;
};

{
	Array.from(document.querySelectorAll('.js-toolbar-scale')).forEach((el) => {
		el.addEventListener('click', (e) => {
			e.preventDefault();
			changeTool(TOOL_SCALE);
		});
	});
	Array.from(document.querySelectorAll('.js-toolbar-select')).forEach((el) => {
		el.addEventListener('click', (e) => {
			e.preventDefault();
			changeTool(TOOL_SELECT);
		});
	});
	Array.from(document.querySelectorAll('.js-toolbar-recenter')).forEach((el) => {
		el.addEventListener('click', (e) => {
			e.preventDefault();
			changeTool(TOOL_RECENTER);
		});
	});
};

const alpacaObjects = do {
	const x = new THREE.Group();
	scenes.main.add(x);
	x;
};

const sceneUrl = '/store/alpaca/index.json';

const target = new THREE.Vector3();

await do {
	const url = sceneUrl;
	fetch(url)
		.then((response) => response.json())
		.then((data) => sceneUpdate(data));
};

const ws = await makeWebSocket(`ws://${window.location.host}${sceneUrl}`);
{
	ws.onopen = open;
	ws.onclose = close;
	ws.onmessage = message;
	ws.onopen();
};

if (display) {
	changeTool(TOOL_RECENTER);
};

function open() {
	console.log('ws open');
};

function close(e) {
	console.log('ws close', e);
};

function message({ data }) {
	const json = JSON.parse(data);

	sceneUpdate(json);
};

function changeTool(newTool) {
	const tools = {
		[TOOL_SELECT]: { onTouchStart: selectTouchStart, onTouchEnd: selectTouchEnd },
		[TOOL_SCALE]: { onTouchStart: scaleTouchStart, onTouchEnd: scaleTouchEnd },
		[TOOL_RECENTER]: { onTouchStart: recenterTouchStart, onTouchEnd: recenterTouchEnd },
	};

	if (changeTool.currentTool) {
		window.removeEventListener('mousedown', tools[changeTool.currentTool].onTouchStart);
		window.removeEventListener('mouseup', tools[changeTool.currentTool].onTouchEnd);
		window.removeEventListener('touchstart', tools[changeTool.currentTool].onTouchStart);
		window.removeEventListener('touchend', tools[changeTool.currentTool].onTouchEnd);
	}
	
	if (newTool === TOOL_SELECT) {
		document.body.classList.add('hide-ui');
	}

	changeTool.currentTool = newTool;
	window.addEventListener('mousedown', tools[newTool].onTouchStart);
	window.addEventListener('mouseup', tools[newTool].onTouchEnd);
	window.addEventListener('touchstart', tools[newTool].onTouchStart);
	window.addEventListener('touchend', tools[newTool].onTouchEnd);
};

async function selectTouchStart(e) {
	e.preventDefault();
	console.warn('selectTouchStart', e);
	const source = e.touches ? e.touches[0] : e;
	const bounds = renderer.context.canvas.getBoundingClientRect();
	const mouse = new THREE.Vector2();
	mouse.x = (source.clientX - bounds.left) / (bounds.right - bounds.left) * 2 - 1;
	mouse.y = (source.clientY - bounds.top) / (bounds.bottom - bounds.top) * -2 + 1;
	console.log(mouse);
	const raycaster = new THREE.Raycaster();
	raycaster.setFromCamera(mouse, camera);
	const intersects = raycaster.intersectObject(scenes.main, true);
	if (intersects.length === 0) return;
	console.log({ intersects });
	for (let { object, uv } of intersects) {
		if (!object.meta.events.tap) continue;
		const result = await fetch(object.meta.events.tap, {
			method: 'PUT',
			body: JSON.stringify({
				object: object.meta,
				uv,
			}, true, 2),
		}).then((res) => res.json());
		console.log(result);
		break;
	}
};

function selectTouchEnd(e) {
	console.warn('selectTouchEnd');
};

function scaleTouchStart(e) {
	console.warn('scaleTouchStart');
};

function scaleTouchEnd(e) {
	console.warn('scaleTouchEnd');
};

function recenterTouchStart(e) {
	if (display) {
		alpacaObjects.position.copy(reticle.position);
	}
};

function recenterTouchEnd(e) {
};

function patchControls(controls) {
	const oldUpdate = controls.update;
	let id = null;
	controls.update = () => {
		const ret = oldUpdate.call(controls);
		if (!id) id = requestAnimationFrame(() => {
			render();
			id = null;
		});
		return ret;
	};
};

async function sceneUpdate(scene) {
	const children = await scene.children.reduce((acc, object) => {
		return acc.then((l) => makeObject(object).then((x) => l.concat(x)));
	}, Promise.resolve([]));
	console.log({ children });
	
	const parent = new THREE.Group();
	children.forEach((object) => {
		parent.add(object);
	});
	
	clear(alpacaObjects);
	alpacaObjects.add(parent);
	
	render();
};

async function makeObject(data) {
	const { children, eulerRotation, scale, material, position, flags={}, events, meta } = data;
	const { useGeometryShader, useBillboard, useLine } = flags;
	
	const texture = material
		? await cachedTexture(material.map).catch((err) => console.error('tex', err))
		: null;
	
	const g = do {
		const parts = useGeometryShader ? 64 : 1,
		      size = 1;
		if (useLine) {
			const geometry = new THREE.Geometry();
			geometry.vertices.push(
				new THREE.Vector3(...meta.start),
				new THREE.Vector3(...meta.end)
			);
			geometry;
		} else {
		      new THREE.PlaneBufferGeometry(size, size, parts, parts);
		}
	};
	
	const m = do {
		if (useGeometryShader) {
			const uniforms = { uTextureMap: { value: texture } },
			      vertexShader = textContent('projectionVertexShader'),
			      fragmentShader = textContent('projectionFragmentShader'),
			      opacity = 0.5,
			      transparent = true;
			new THREE.ShaderMaterial({
				uniforms,
				vertexShader,
				fragmentShader,
				opacity,
				transparent,
			});
		} else if (material) {
			const map = texture,
			      side = THREE.DoubleSide,
			      opacity = 1.0,
			      transparent = false,
			      depthWrite = false,
			      depthTest = false;
			new THREE.MeshBasicMaterial({
				map,
				side,
				opacity,
				transparent,
				depthWrite,
				depthTest,
			});
		} else if (useLine) {
			new THREE.LineBasicMaterial({
				color: 0x000000,
			});
		} else {
			null;
		}
	};
	
	const mesh = do {
		if (material) {
			const mesh = new THREE.Mesh(g, m);
			mesh;
		} else if (useLine) {
			new THREE.Line(g, m);
		} else {
			new THREE.Group();
		}
	};
	
	if (eulerRotation) mesh.rotation.set(...eulerRotation.map(THREE.Math.degToRad));
	if (position) mesh.position.set(...position);
	if (scale) mesh.scale.set(...scale);
	mesh.meta = data;
	
	mesh.isDisposed = false;
	g.addEventListener('dispose', () => {
		console.log('disposed');
		mesh.isDisposed = true;
	});

	mesh.useBillboard = useBillboard;
	
	if (useBillboard) {
		startRunner(mesh, updateBillboard);
	}
	
	if (children) {
		for (let object of children) {
			mesh.add(await makeObject(object));
		}
	}
	
	return mesh;
};

function makeWebSocket(url) {
	return new Promise((resolve, reject) => {
		const ws = new WebSocket(url);
		ws.onopen = () => resolve(ws);
		ws.onerror = () => reject(ws);
		if (ws.readyState === WebSocket.OPEN) ws.onopen();
	});
};

function textContent(id) {
	return document.getElementById(id).textContent;
};

async function cachedTexture(url) {
	if (!cachedTexture.imageCache) cachedTexture.imageCache = new Map();
	const imageCache = cachedTexture.imageCache;
	
	if (imageCache.has(url)) {
		return imageCache.get(url);
	}
	
	const texture = await loadTexture(url);
	imageCache.set(url, texture);
	return texture;
};

function flatten(arrayOfArrays) {
	return [].concat(...arrayOfArrays);
};

function loadTexture(url) {
	return new Promise((resolve, reject) => {
		loader.load(url, (texture) => {
			resolve(texture);
		}, undefined, (err) => {
			reject(err);
		});
	});
};

function clear(obj) {
	while(obj.children.length) {
		clear(obj.children[0]);
		obj.remove(obj.children[0]);
	}
	if (obj.geometry) {
		obj.geometry.dispose();
		obj.geometry = null;
	}
	if (obj.material) {
		if (obj.material.map) {
			obj.material.map.dispose();
			obj.material.map = undefined;
		}
		obj.material.dispose();
		obj.material = null;
	}
};

function startRunner(obj, f) {
	console.log('startRunner', { obj, f });
	doit();
	function doit() {
		if (obj.isDisposed) {
			console.log('bailing out');
			return;
		}
		
		f(obj).then(() => {
			requestAnimationFrame(doit);
		});
	};
};

async function updateBillboard(obj) {
	if (!obj.useBillboard) {
		return;
	}
	if (Math.random() < 0.001)
	console.log(obj.position, center.position);
	obj.lookAt(center.position);
};

async function updateDynamicImage(obj) {
	if (!obj.dynamicImage) {
		return;
	}
	const target = display ? obj.getWorldPosition() : controls.target,
	      eye = camera.getWorldPosition(),
	      pos = new THREE.Vector3().subVectors(target, eye),
	      rotationOffset = obj.quaternion.clone().inverse(),
	      rotation = camera.quaternion.clone().multiply(rotationOffset),
	      view = new THREE.Euler().setFromQuaternion(rotation, 'ZYX'),
	      up = camera.up;
	
	const replacements = {
		px: pos.x, py: pos.y, pz: pos.z,
		vx: -THREE.Math.radToDeg(view.x), vy: THREE.Math.radToDeg(view.y), vz: 0, 
		ux: up.x, uy: up.y, uz: up.z,
	};
	
	p1.update(replacements.px * 100 + 1000, 2000);
	p2.update(replacements.py * 100 + 1000, 2000);
	p3.update(replacements.pz * 100 + 1000, 2000);
	
	const url = obj.image.replace(/\$\{([^}]+)\}/g, (full, expr) => {
		return math.eval(expr, replacements);
	});
	
	if (obj.material.uniforms.uTextureMap.value) {
		obj.material.uniforms.uTextureMap.value.dispose();
	}
	const texture = await loadTexture(url);
	obj.material.uniforms.uTextureMap.value = texture;
	obj.material.needsUpdate = true;
}

async function render() {
	if (display) {
		reticle.update();
		view.render();
		camera.updateProjectionMatrix();
	}
	
	controls.update();
	
	renderer.clearDepth();
	renderer.render(scenes.reticle, camera);
	renderer.clearDepth();
	renderer.render(scenes.main, camera);
};

async function step(timestamp) {
	await render();
	requestAnimationFrame(step);
};

if (display) {
	requestAnimationFrame(step);
}

})()
</script>
