<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  #theLogger {
    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;
    display: none;
  }

  .hide-ui .toolbar,
  .hide-ui #theLogger,
  .hide-ui canvas[width="80"] {
    display: none !important;
  }
</style>

<body>
  <div id="app">
    <div id="canvas"></div>
  </div>
  <div id="theLogger"></div>
  <div id="scene-tree"></div>
  <script>
    (function () {
      console.log = makeLogger(console.log, 'log');
      console.warn = makeLogger(console.warn, 'warn');
      console.error = makeLogger(console.error, 'error');

      function makeLogger(old, type) {
        const logger = document.getElementById('theLogger');

        return function () {
          const pre = document.createElement('pre');
          const text = document.createTextNode(type + ':' + Array.from(arguments).join(''));
          pre.appendChild(text);
          logger.appendChild(pre);
          old.apply(console, arguments);
        };

      }
    })();
  </script>
  <script type="text/javascript" src="../js/alpaca.js"></script>
  <script type="text/javascript" src="../js/object-store.js"></script>
  <script type="text/javascript" src="../js/make-tree.js"></script>
  <script type="text/javascript" src="../js/watch-tree.js"></script>
  <script type="text/javascript" src="../js/patch-tree.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script src="https://threejs.org/build/three.min.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/three.js/c67fbdcc64ffc970d732d9d3ce77a930761f7f31/examples/js/QuickHull.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/three.js/c67fbdcc64ffc970d732d9d3ce77a930761f7f31/examples/js/geometries/ConvexGeometry.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/three.js/c1afee8fea2157a3846b7b9bdf00d4f69d7076eb/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.rawgit.com/google-ar/three.ar.js/83d4f1b2626081d44a3d49a7f16846ddeb144beb/third_party/three.js/VRControls.js"></script>
  <script src="https://cdn.rawgit.com/google-ar/three.ar.js/83d4f1b2626081d44a3d49a7f16846ddeb144beb/dist/three.ar.min.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/stats.js/28632bd87e0ea56acafc9b8779d813eb95e62c08/build/stats.min.js"></script>
  <script src="https://unpkg.com/mathjs@4.0.0/dist/math.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
  <script type="text/babel" data-presets="stage-0">
(async () => {

const contentType = 'application/json', namespace = 'alpaca', name = 'index.json';

// three.ar.js returns falsey if this is not an AR device.
// Can be used to detect if this is a desktop web browser.
const display = do {
	await THREE.ARUtils.getARDisplay();
};

const loader = do {
	new THREE.TextureLoader();
};

const objectLoader = do{
	new THREE.ObjectLoader();
}

const renderer = do {
	const renderer = new THREE.WebGLRenderer({ alpha: true });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.autoClear = false;
	renderer;
};

const canvas = do {
	const canvas = renderer.domElement;
	document.getElementById('canvas').appendChild(canvas);
	canvas;
};

const scenes = do {
	const main = new THREE.Scene(),
	      reticle = new THREE.Scene(),
	      scenes = { main, reticle };
	window.scenes = scenes;
	scenes;
};

const view = do {
  if (display) {
    new THREE.ARView(display, renderer);
  } else {
    null;
  }
};

const camera = do {
        const fov = 60,
              aspect = window.innerWidth / window.innerHeight;
        if (display) {
                const zNear = display.depthNear,
                      zFar = display.depthFar,
                      camera = new THREE.ARPerspectiveCamera(display, fov, aspect, zNear, zFar);
                camera;
        } else {
                const zNear = 0.1,
                      zFar = 1000,
                      camera = new THREE.PerspectiveCamera(fov, aspect, zNear, zFar);
                camera.position.set(0, 0.1, 0.1);
                camera;
        }
};

const reticle = do {
        if (display) {
                const inRadius = 0.03,
                      outRadius = 0.04,
                      color = 0xff0077,
                      easing = 0.25,
                      reticle = new THREE.ARReticle(display, inRadius, outRadius, color, easing);
                scenes.reticle.add(reticle);
                reticle;
        } else {
                null;
        }
};

var stats1, stats2, stats3;
const p1 = do {
	const panel = do {
		const label = 'p1',
		      fg = '#ccc',
		      bg = '#222';
		new Stats.Panel(label, fg, bg);
	};
	
	const stats = do {
		const stats = new Stats();
		stats.addPanel(panel);
		stats.showPanel(0);
		stats.dom.style.top = `${0 * 48}px`;
		document.body.appendChild(stats.dom);
		stats1 = stats;
		stats;
	};
	
	panel;
};

const p2 = do {
	const panel = do {
		const label = 'p2',
		      fg = '#ccc',
		      bg = '#222';
		new Stats.Panel(label, fg, bg);
	};
	
	const stats = do {
		const stats = new Stats();
		stats.addPanel(panel);
		stats.showPanel(2);
		stats.dom.style.top = `${1 * 48}px`;
		document.body.appendChild(stats.dom);
		stats2 = stats;
		stats;
	};
	
	panel;
};

const p3 = do {
	const panel = do {
		const label = 'p3',
		      fg = '#ccc',
		      bg = '#222';
		new Stats.Panel(label, fg, bg);
	};
	
	const stats = do {
		const stats = new Stats();
		stats.addPanel(panel);
		stats.showPanel(1);
		stats.dom.style.top = `${2 * 48}px`;
		document.body.appendChild(stats.dom);
		stats3 = stats;
		stats;
	};
	
	panel;
};

const alpacaObjects = do {
	const group = new THREE.Group();
	scenes.main.add(group);
	group;
};


function addTouchControls() {
  let canvas = document.getElementsByTagName("canvas")[0],
    hammer = new Hammer(canvas),
    selectedObject = alpacaObjects;

  hammer.get('pinch').set({ enable: true });
  hammer.on('pinch', ev => {
    selectedObject.scale.set(
      selectedObject.scale.x * ev.scale,
      selectedObject.scale.y * ev.scale,
      selectedObject.scale.z * ev.scale
    );
    selectedObject.updateMatrixWorld();
  });

  let raycaster = new THREE.Raycaster(),
    mouse = new THREE.Vector2();
  hammer.on('tap', ev => {
    mouse.x = (ev.center.x / window.innerWidth) * 2 - 1;
    mouse.y = - (ev.center.y / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    let selected = raycaster.intersectObjects(alpacaObjects.children, true);
    if (typeof selected !== 'undefined') {
      let changed = false;
      for (let i = 0, n = selected.length; i < n; i++) {
        let transformed = selected[i].object.userData.canBeTransformed;
        if (typeof transformed === 'undefined' || transformed === true) {
          selectedObject = selected[i].object;
          changed = true;
          break;
        }
      }
      if (!changed) selectedObject = alpacaObjects;
    }
    opacityChange(selectedObject, 0.8);
    setTimeout(() => opacityChange(selectedObject, 1), 100);
  });

  function opacityChange(obj, value) {
    if (obj.material) obj.material.opacity = value;
    for (let child of obj.children) {
      opacityChange(child, value);
    }
  }

  hammer.on('press', ev => {
    selectedObject.position.set(
      camera.position.x,
      camera.position.y,
      camera.position.y
    );
    selectedObject.rotation.set(
      camera.rotation.x,
      camera.rotation.y,
      camera.rotation.z
    );
  });


  hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });
  let lastPosition;
  hammer.on('panstart panmove panend', ev => {
    let currentPosition = { x: ev.center.x + ev.deltaX, y: ev.center.y + ev.deltaY };
    if (ev.type == "panstart") {
      lastPosition = currentPosition;
    }

    let change = { x: currentPosition.x - lastPosition.x, y: currentPosition.y - lastPosition.y },
      w = document.body.clientWidth,
      h = document.body.clientHeight;

    selectedObject.rotation.set(
      selectedObject.rotation.x + (change.y / w) * Math.PI,
      selectedObject.rotation.y + (change.x / w) * Math.PI,
      selectedObject.rotation.z
    );
    
    lastPosition = currentPosition;
  })
}

const controls = do {
  if (display) {
    const controls = new THREE.VRControls(camera);
    addTouchControls();
    controls;
  } else {
    const controls = new THREE.OrbitControls(camera);
    patchControls(controls);
    controls;
  }
};

Alpaca.configure({ host: "accona.eecs.utk.edu:8599", prefix: "store" });

const initial = await Alpaca.load(contentType, namespace, name).then(res => res.json());
processScene(initial);

const onMessage = e => {
  const json = JSON.parse(e.data);
  processScene(json);
}
Alpaca.listen(namespace, name, onMessage);

function processScene(json) {
	objectLoader.parse(json, updateScene);
};

function updateScene(object) {
	clear(alpacaObjects);
	alpacaObjects.add(object);
};

// Re-render when the user rotates the scene.
// Used to prevent re-rendering too often (if the render function is
// not in a requestAnimationFrame loop).
function patchControls(controls) {
        const oldUpdate = controls.update;
        let id = null;
        controls.update = () => {
                const ret = oldUpdate.call(controls);
                if (!id) id = requestAnimationFrame(() => {
                        render();
                        id = null;
                });
                return ret;
        };
};

function makeWebSocket(url) {
	return new Promise((resolve, reject) => {
		const ws = new WebSocket(url);
		ws.onopen = () => resolve(ws);
		ws.onerror = () => reject(ws);
		if (ws.readyState === WebSocket.OPEN) ws.onopen();
	});
};

// wraps THREE.js TextureLoader in a promise.
function loadTexture(url) {
	return new Promise((resolve, reject) => {
		loader.load(url, (texture) => {
			resolve(texture);
		}, undefined, (err) => {
			reject(err);
		});
	});
};

// empty a tree of THREE.js objects to reclaim their memory.
function clear(obj) {
	while(obj.children.length) {
		clear(obj.children[0]);
		obj.remove(obj.children[0]);
	}
	if (obj.geometry) {
		obj.geometry.dispose();
		obj.geometry = null;
	}
	if (obj.material && obj.material.map) {
		if (obj.material.map) {
			obj.material.map.dispose();
			obj.material.map = undefined;
		}
		obj.material.dispose();
		obj.material = null;
	}
};

async function render() {
	stats1.begin();
	stats2.begin();
	stats3.begin();
	
	if (display) {
		reticle.update();
		view.render();
		camera.updateProjectionMatrix();
	
		//controls.update();
	}

	renderer.clearDepth();
	renderer.render(scenes.reticle, camera);
	renderer.clearDepth();
	renderer.render(scenes.main, camera);
	
	stats3.end();
	stats2.end();
	stats1.end();
};

function step(timestamp) {
	render();
	requestAnimationFrame(step);
};

requestAnimationFrame(step);

})();
</script>